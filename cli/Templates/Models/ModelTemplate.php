<?php

namespace PromCMS\Cli\Templates\Models;

use PhpParser\Node\Stmt;
use PromCMS\Core\PromConfig\Entity;
use PhpParser\Node;
use PromCMS\Core\PromConfig\Entity\Column;
use PromCMS\Core\PromConfig\Entity\RelationshipColumn;

class ModelTemplate extends \PromCMS\Cli\Templates\Models\Abstract\ModelTemplate
{
  public function __construct(string $root, Entity $entity, protected ModelTemplateMode $mode)
  {
    parent::__construct($root, $entity, $mode);

    $this->loadExisting();

    $this->header
      ->addLine('This file is generated by PromCMS, however you can add methods and other logic to this class')
      ->addLine('as this file will be just checked for presence of class in next models sync.');
  }

  protected function getNamespace()
  {
    $possibleNamespace = null;
    foreach ($this->ast as $stmt) {
      if ($stmt instanceof Stmt\Namespace_) {
        $possibleNamespace = $stmt;
      }
    }

    // Create anew if it does not exist yet
    if (($possibleNamespace instanceof Stmt\Namespace_) === false) {
      $headerAsExpression = $this->header->toExpression();
      $possibleNamespace = $this->ast[] = new Stmt\Namespace_(
        name: new Node\Name($this->namespace),
        attributes: $headerAsExpression ? [
          'comments' => [
            $headerAsExpression
          ]
        ] : []
      );
    }

    return $possibleNamespace;
  }

  /**
   * Gets existing class or creates a new one
   */
  protected function getClass(): Stmt\Class_
  {
    $namespace = $this->getNamespace();

    $isOutputLocalized = $this->mode === ModelTemplateMode::LOCALIZED;
    $phpName = $isOutputLocalized ? $this->entity->getTranslationPhpName() : $this->entity->phpName;
    $class = null;

    foreach ($namespace->stmts as $stmt) {
      if ($stmt instanceof Stmt\Class_ && $stmt->name->name === $phpName) {
        $class = $stmt;
      }
    }

    if ($class === null) {
      $class = new Stmt\Class_($phpName);
      $namespace->stmts[] = $class;
    }

    return $class;
  }

  private function updateNamespace()
  {
    $namespace = $this->getNamespace();

    /** @var array<Stmt\Use_> */
    $useStmts = array_filter($namespace->stmts, fn($stmt) => $stmt instanceof Stmt\Use_);
    $otherStmts = array_filter($namespace->stmts, fn($stmt) => ($stmt instanceof Stmt\Use_) === false);

    $enforcedUses = parent::getUseStatements($this->entity);
    $existingUsesAsArray = [];
    foreach ($useStmts as $stmt) {
      foreach ($stmt->uses as $stmtUse) {
        $existingUsesAsArray[$stmtUse->name->name] = $stmtUse->alias;
      }
    }

    // Unsets enforced
    foreach ($enforcedUses as $stmt) {
      foreach ($stmt->uses as $stmtUse) {
        $useName = $stmtUse->name->name;

        if (isset($existingUsesAsArray[$useName])) {
          unset($existingUsesAsArray[$useName]);
        }
      }
    }

    $uses = $enforcedUses;
    foreach ($existingUsesAsArray as $name => $alias) {
      $uses[] = new Stmt\Use_(
        uses: [
          new Stmt\UseUse(new Node\Name($name), $alias)
        ]
      );
    }

    $namespace->stmts = [...$uses, ...$otherStmts];
  }

  private function updateClass(): void
  {
    $class = $this->getClass();

    $isOutputLocalized = $this->mode === ModelTemplateMode::LOCALIZED;

    $phpName = $isOutputLocalized ? $this->entity->getTranslationPhpName() : $this->entity->phpName;
    $class->extends = new Node\Name('Base\\' . $phpName);

    $attributes = [
      new Node\Attribute(new Node\Name('ORM\Entity')),
      new Node\Attribute(new Node\Name('ORM\Table'), [
        new Node\Arg(
          name: new Node\Identifier('name'),
          value: new Node\Scalar\String_(
            $isOutputLocalized
            ? $this->entity->getTranslationTableName()
            : $this->entity->tableName
          )
        )
      ]),
    ];

    foreach ($class->attrGroups as $attGroup) {
      foreach ($attGroup->attrs as $attr) {
        if ($attr->name instanceof Node\Name && $attr->name->name === 'ORM\EntityListeners') {
          $attributes[] = $attr;
        }
      }
    }

    $uniqueConstraintColumns = array_filter($this->entity->getColumns(), fn(Column|RelationshipColumn $column) => !$column->localized && $column->unique);
    if ($isOutputLocalized) {
      $attributes[] = new Node\Attribute(new Node\Name('ORM\UniqueConstraint'), [
        new Node\Arg(
          name: new Node\Identifier('name'),
          value: new Node\Scalar\String_(
            ($isOutputLocalized
              ? $this->entity->getTranslationTableName()
              : $this->entity->tableName) . '_unique_idx'
          )
        ),
        new Node\Arg(
          name: new Node\Identifier('columns'),
          value: new Node\Expr\Array_(
            [
              new Node\Expr\ArrayItem(
                new Node\Scalar\String_('locale')
              ),
              new Node\Expr\ArrayItem(
                new Node\Scalar\String_('object_id')
              )
            ]
          )
        ),
      ]);

      $uniqueConstraintColumns = array_filter($this->entity->getLocalizedColumns(), fn(Column|RelationshipColumn $column) => is_string($column->unique));
    } else {
      $attributes[] = new Node\Attribute(new Node\Name('PROM\PromModel'), [
        new Node\Arg(
          name: new Node\Identifier('ignoreSeeding'),
          value: new Node\Expr\ConstFetch(
            new Node\Name(json_encode(!$this->entity->ignoreSeeding))
          )
        )
      ]);
    }

    $uniqueConstraintColumns = array_filter($uniqueConstraintColumns, fn(Column|RelationshipColumn $column) => is_string($column->unique));

    $uniqueColumnGroups = [];
    foreach ($uniqueConstraintColumns as $uniqueColumn) {
      $uniqueColumnGroups[$uniqueColumn->unique] = array_merge($uniqueColumnGroups[$uniqueColumn->unique] ?? [], [$uniqueColumn->name]);
    }

    foreach ($uniqueColumnGroups as $groupName => $groupColumns) {
      $attributes[] = new Node\Attribute(new Node\Name('ORM\UniqueConstraint'), [
        new Node\Arg(
          name: new Node\Identifier('name'),
          value: new Node\Scalar\String_($groupName)
        ),
        new Node\Arg(
          name: new Node\Identifier('columns'),
          value: new Node\Expr\Array_(
            array_map(fn($columnName) => new Node\Expr\ArrayItem(
              new Node\Scalar\String_($columnName)
            ), $groupColumns)
          )
        ),
      ]);
    }

    $attributes[] = new Node\Attribute(new Node\Name('ORM\HasLifecycleCallbacks'));

    $class->attrGroups = [
      new Node\AttributeGroup($attributes)
    ];
  }
  public function generateAst()
  {
    $this->updateNamespace();
    $this->updateClass();
    parent::generateAst();
  }
}